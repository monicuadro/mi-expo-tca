<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Espejo Distorsionado</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100vh;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 20;
      background: rgba(0,0,0,0.7);
      padding: 15px;
      border-radius: 10px;
      color: white;
      font-family: Arial, sans-serif;
    }
    #startBtn, #toggleShaderBtn, #debug2D {
      padding: 10px 20px;
      background: rgba(255,255,255,0.8);
      border: none;
      font-size: 16px;
      cursor: pointer;
      border-radius: 5px;
      margin: 5px 0;
      display: block;
      width: 100%;
    }
    #distortionSlider {
      width: 100%;
      margin: 10px 0;
    }
    #distortionValue {
      font-size: 14px;
      text-align: center;
    }
    label {
      display: block;
      margin-bottom: 5px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
<div id="controls">
  <button id="startBtn">Activar Cámara</button>
  <button id="toggleShaderBtn" style="display: none;">Desactivar Distorsión</button>
  <button id="debug2D" style="display: none; background: rgba(0,255,0,0.8);">Modo Debug 2D (Simple)</button>
  <label for="distortionSlider" style="display: none;">Intensidad de Distorsión:</label>
  <input type="range" id="distortionSlider" min="0" max="0.1" step="0.01" value="0.02" style="display: none;">
  <div id="distortionValue" style="display: none;">Intensidad: 0.02</div>
</div>

<script id="fragShader" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tex0;
uniform vec2 resolution;
uniform float time;
uniform float distortionIntensity;

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  uv.y = 1.0 - uv.y; // Flip Y para video capture (arregla orientación invertida)

  // Distorsión ondulada ajustable
  float distortionX = distortionIntensity * sin(uv.y * 10.0 + time * 2.0);
  float distortionY = distortionIntensity * cos(uv.x * 10.0 + time * 1.5);
  uv.x = clamp(uv.x + distortionX, 0.0, 1.0);
  uv.y = clamp(uv.y + distortionY, 0.0, 1.0);

  vec3 col = texture2D(tex0, uv).rgb;
  gl_FragColor = vec4(col, 1.0);
}
</script>

<script id="simpleFragShader" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tex0;
uniform vec2 resolution;

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;
  uv.y = 1.0 - uv.y; // Flip Y para video capture (arregla orientación y visibilidad)

  vec3 col = texture2D(tex0, uv).rgb;
  gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
let cam;
let shaderProgram;
let simpleShaderProgram;
let started = false;
let useDistortion = false;
let distortionIntensity = 0.02;
let useWEBGL = true; // Toggle para modo 2D debug
let myCanvas; // Para referencia

function setup() {
  myCanvas = createCanvas(windowWidth, windowHeight, WEBGL);
  myCanvas.style('display', 'block');

  // Proyección ortográfica corregida: left, right, bottom (Y positivo abajo), top (Y negativo arriba), near, far
  ortho(-width / 2, width / 2, height / 2, -height / 2, 0.1, 100);

  let vertSource = `
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;
    uniform mat4 uProjectionMatrix;
    uniform mat4 uModelViewMatrix;
    void main() {
      vTexCoord = aTexCoord;
      gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
    }
  `;

  shaderProgram = createShader(vertSource, document.getElementById("fragShader").textContent);
  simpleShaderProgram = createShader(vertSource, document.getElementById("simpleFragShader").textContent);

  noStroke();

  // Controles
  select("#startBtn").mousePressed(startCamera);
  select("#toggleShaderBtn").mousePressed(toggleDistortion);
  select("#debug2D").mousePressed(toggleDebug2D);

  let slider = select("#distortionSlider");
  slider.input(updateDistortion);

  updateDistortion();
}

function startCamera() {
  const constraints = {
    video: {
      facingMode: "user", // Cambié a frontal por defecto para testing (más confiable); cambia a "environment" si quieres trasera
      width: { ideal: 640, max: 1280 }, // Resolución más baja para estabilidad y nitidez
      height: { ideal: 480, max: 720 },
      frameRate: { ideal: 30 }
    },
    audio: false
  };

  cam = createCapture(constraints, () => {
    console.log("Cámara activada. Resolución:", cam.width, "x", cam.height);
    cam.size(width, height); // Ajustar al canvas
    cam.play();
    cam.loop();
    console.log("Video ready - should be visible now");
  });
  cam.hide();

  started = true;
  select("#startBtn").hide();
  select("#toggleShaderBtn").show();
  select("#debug2D").show();
  select("#distortionSlider").show();
  select("#distortionSlider").parent().show(); // Mostrar label y slider
  select("#distortionValue").show();
}

function toggleDistortion() {
  useDistortion = !useDistortion;
  select("#toggleShaderBtn").html(useDistortion ? "Desactivar Distorsión" : "Activar Distorsión");
  console.log("Distorsión:", useDistortion ? "Activada" : "Desactivada");
}

function updateDistortion() {
  distortionIntensity = parseFloat(select("#distortionSlider").value());
  select("#distortionValue").html("Intensidad: " + distortionIntensity.toFixed(2));
  if (useDistortion && started && useWEBGL) {
    shaderProgram.setUniform("distortionIntensity", distortionIntensity);
  }
}

function toggleDebug2D() {
  useWEBGL = !useWEBGL;
  if (useWEBGL) {
    // Recrear canvas en WEBGL
    myCanvas = createCanvas(windowWidth, windowHeight, WEBGL);
    myCanvas.style('display', 'block');
    ortho(-width / 2, width / 2, height / 2, -height / 2, 0.1, 100);
    console.log("Modo WEBGL (con shader)");
  } else {
    // Recrear en 2D para debug simple
    myCanvas.remove();
    myCanvas = createCanvas(windowWidth, windowHeight);
    myCanvas.style('display', 'block');
    console.log("Modo 2D Debug (sin shader, cámara cruda)");
  }
  select("#debug2D").html(useWEBGL ? "Modo Debug 2D (Simple)" : "Volver a WEBGL");
}

function draw() {
  background(0);

  if (!started || !cam) {
    // Mensaje simple de carga
    if (useWEBGL) {
      push();
      resetMatrix();
      ortho();
      textAlign(CENTER);
      textSize(32);
      fill(255);
      text("Cargando cámara... (presiona Activar)", 0, 0);
      pop();
    } else {
      textAlign(CENTER);
      textSize(32);
      fill(255);
      text("Cargando cámara...", width/2, height/2);
    }
    return;
  }

  if (useWEBGL) {
    // Modo WEBGL con shader
    resetMatrix();

    let currentShader = useDistortion ? shaderProgram : simpleShaderProgram;
    shader(currentShader);

    currentShader.setUniform("tex0", cam);
    currentShader.setUniform("resolution", [width, height]);
    if (useDistortion) {
      currentShader.setUniform("time", millis() / 1000.0);
      currentShader.setUniform("distortionIntensity", distortionIntensity);
    }

    // Usar plane() con scale para flip Y si es necesario, pero el flip está en shader
    plane(width, height);

    resetShader();
  } else {
    // Modo 2D debug: mostrar cámara cruda sin WEBGL/shader
    image(cam, 0, 0, width, height);
  }
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  if (started && cam) {
    cam.size(windowWidth, windowHeight);
  }
  if (useWEBGL) {
    ortho(-width / 2, width / 2, height / 2, -height / 2, 0.1, 100);
  }
}
</script>
</body>
</html>

