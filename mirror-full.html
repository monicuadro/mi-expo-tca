<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Espejo Distorsionado: Reflexión y Dismorfia Corporal</title>
<style>
  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #0f0f23 0%, #1a0d2e 50%, #2d1b69 100%);
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
  }

  h1 {
    font-size: 1.8rem;
    font-weight: 300;
    margin: 20px 0 10px;
    text-align: center;
    letter-spacing: 1px;
    color: #e0d7ff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  p.description {
    max-width: 600px;
    text-align: center;
    font-size: 1rem;
    line-height: 1.5;
    margin: 0 0 20px;
    color: #d1d5db;
    opacity: 0.9;
  }

  #stage {
    position: relative;
    width: min(480px, 100%);
    height: auto;
    aspect-ratio: var(--aspect-ratio, 480/640);
    margin: 20px 0;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 
      0 10px 30px rgba(139, 92, 246, 0.3),
      0 4px 20px rgba(0,0,0,0.4),
      inset 0 2px 4px rgba(255,255,255,0.1);
    transition: box-shadow 0.3s ease;
    background: #000; /* Fondo negro para evitar flashes */
  }

  #stage:hover {
    box-shadow: 
      0 15px 40px rgba(139, 92, 246, 0.4),
      0 6px 25px rgba(0,0,0,0.5),
      inset 0 2px 4px rgba(255,255,255,0.1);
  }

  video, canvas {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    object-fit: cover; /* Mantiene proporciones sin estirar */
    border-radius: 16px;
  }

  #controls {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-items: center;
    width: 100%;
    max-width: 480px;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    align-items: center;
  }

  label {
    font-size: 0.95rem;
    color: #e0d7ff;
    font-weight: 500;
    margin-bottom: 4px;
  }

  #intensity {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.1);
    outline: none;
    -webkit-appearance: none;
  }

  #intensity::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #8B5CF6, #A78BFA);
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
  }

  #intensity::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #8B5CF6, #A78BFA);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
  }

  .btn-group {
    display: flex;
    gap: 12px;
    width: 100%;
    justify-content: center;
  }

  .btn {
    padding: 12px 24px;
    border-radius: 12px;
    border: none;
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    min-width: 140px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  }

  #start {
    background: linear-gradient(135deg, #8B5CF6, #A78BFA);
    color: #fff;
  }

  #start:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
  }

  #stop {
    background: linear-gradient(135deg, #6B7280, #9CA3AF);
    color: #fff;
  }

  #stop:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(107, 114, 128, 0.4);
  }

  .btn:active {
    transform: translateY(0);
  }

  @media (max-width: 600px) {
    body {
      padding: 10px;
    }
    
    h1 {
      font-size: 1.5rem;
      margin: 10px 0 5px;
    }
    
    p.description {
      font-size: 0.9rem;
      margin: 0 0 15px;
      padding: 0 10px;
    }
    
    #stage {
      width: 100%;
      max-width: none;
      margin: 10px 0;
      aspect-ratio: var(--aspect-ratio, 9/16); /* Default portrait para móviles */
      border-radius: 12px;
    }
    
    #controls {
      margin-top: 15px;
      gap: 12px;
      max-width: none;
    }
    
    .btn-group {
      flex-direction: column;
      gap: 8px;
    }
    
    .btn {
      min-width: 200px;
      width: 100%;
    }
  }

  @media (orientation: landscape) and (max-width: 600px) {
    body {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
      padding: 10px;
    }
    
    #stage {
      width: 50vw;
      height: auto;
      aspect-ratio: var(--aspect-ratio, 16/9); /* Ajuste para landscape */
      max-height: 80vh;
    }
    
    #controls {
      width: 45vw;
      margin: 0;
      align-self: flex-start;
    }
    
    h1, p.description {
      width: 100%;
      text-align: center;
    }
  }
</style>
</head>
<body>
<h1>Espejo Distorsionado</h1>
<p class="description">
  Esta experiencia te invita a mirarte en un espejo digital que distorsiona tu reflejo, explorando la dismorfia corporal. Ajusta la intensidad para ver cómo la percepción de tu imagen puede alterarse, recordándonos cómo el cuerpo se ve a través de lentes subjetivos. Usa la cámara frontal para una reflexión íntima y reflexiva.
</p>

<div id="stage">
  <video id="video" autoplay playsinline muted></video>
  <canvas id="out"></canvas>
</div>

<div id="controls">
  <div class="control-group">
    <label for="intensity">Intensidad de Distorsión (0-100)</label>
    <input id="intensity" type="range" min="0" max="100" value="0">
  </div>
  
  <div class="btn-group">
    <button id="start" class="btn">Iniciar Experiencia</button>
    <button id="stop" class="btn">Restaurar Espejo</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.min.js"></script>
<script>
(async function(){
  const video = document.getElementById('video');
  const out = document.getElementById('out');
  const stage = document.getElementById('stage');
  const intensity = document.getElementById('intensity');
  const startBtn = document.getElementById('start');
  const stopBtn = document.getElementById('stop');

  let net = null, running = false, offCanvas = null;
  let W = 480, H = 640; // Defaults
  let currentMaskData = null;
  let frameCount = 0;
  const SEGMENTATION_INTERVAL = 3;
  const MASK_BLUR_RADIUS = 4;
  let prevTime = 0;
  const SMOOTHING_FACTOR = 0.7;

  // Función para actualizar dimensiones basadas en video
  function updateDimensions() {
    if (video.videoWidth > 0 && video.videoHeight > 0) {
      W = video.videoWidth;
      H = video.videoHeight;
      out.width = W;
      out.height = H;
      
      // Crear o actualizar offCanvas
      if (!offCanvas) {
        offCanvas = document.createElement('canvas');
      }
      offCanvas.width = W;
      offCanvas.height = H;
      
      // Actualizar CSS aspect-ratio dinámicamente
      const aspectRatio = W / H;
      document.documentElement.style.setProperty('--aspect-ratio', aspectRatio);
      
      // Ajustar stage si es necesario (para consistencia)
      stage.style.aspectRatio = `${aspectRatio}`;
      
      console.log(`Dimensiones actualizadas: ${W}x${H} (aspect: ${aspectRatio})`);
    }
  }

  // Listener para cambios en video (e.g., después de play o resize)
  video.addEventListener('loadedmetadata', updateDimensions);
  video.addEventListener('resize', updateDimensions);
  window.addEventListener('orientationchange', () => {
    setTimeout(updateDimensions, 100); // Delay para que se estabilice
  });

  const offCtx = offCanvas ? offCanvas.getContext('2d') : null;
  const outCtx = out.getContext('2d');

  async function setupCamera() {
    try {
      const constraints = {
        video: {
          facingMode: 'user',
          width: { ideal: 640 }, // Ideal para móviles, pero flexible
          height: { ideal: 480 },
          aspectRatio: { ideal: 4/3 } // Preferir portrait común en front-facing
        },
        audio: false
      };
      
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      await video.play();
      
      // Esperar un frame para obtener dimensiones reales
      await new Promise(resolve => {
        const checkReady = () => {
          if (video.videoWidth > 0) {
            updateDimensions();
            resolve();
          } else {
            requestAnimationFrame(checkReady);
          }
        };
        checkReady();
      });
    } catch (err) {
      console.error('Error accediendo a cámara:', err);
      alert('No se pudo acceder a la cámara. Asegúrate de permitir el acceso.');
    }
  }

  async function loadModel() {
    net = await bodyPix.load({ 
      architecture: 'MobileNetV1', 
      outputStride: 16, 
      multiplier: 0.5 
    });
  }

  function blurMask(maskCtx, radius) {
    const tempBlur = document.createElement('canvas');
    tempBlur.width = W;
    tempBlur.height = H;
    const tempBlurCtx = tempBlur.getContext('2d');
    
    tempBlurCtx.filter = `blur(${radius}px)`;
    tempBlurCtx.drawImage(maskCtx.canvas, 0, 0);
    tempBlurCtx.filter = 'none';
    
    maskCtx.clearRect(0, 0, W, H);
    maskCtx.drawImage(tempBlur, 0, 0);
  }

  async function frameLoop(currentTime) {
    if (!running) return;
    
    const deltaTime = (currentTime - prevTime) / 1000;
    prevTime = currentTime;

    // Flip horizontal (espejo)
    if (offCtx) {
      offCtx.save();
      offCtx.scale(-1, 1);
      offCtx.drawImage(video, -W, 0, W, H);
      offCtx.restore();
    }

    // Segmentación optimizada
    if (frameCount % SEGMENTATION_INTERVAL === 0) {
      if (net && offCanvas) {
        const segmentation = await net.segmentPerson(offCanvas, { 
          internalResolution: 'high', 
          segmentationThreshold: 0.7 
        });
        const mask = bodyPix.toMask(segmentation, {r:0,g:0,b:0,a:0}, {r:0,g:0,b:0,a:255});
        
        const maskCanvas = document.createElement('canvas');
        maskCanvas.width = W;
        maskCanvas.height = H;
        const maskCtx = maskCanvas.getContext('2d');
        maskCtx.putImageData(mask, 0, 0);
        
        blurMask(maskCtx, MASK_BLUR_RADIUS);
        
        currentMaskData = maskCtx.getImageData(0, 0, W, H);
      }
    }
    frameCount++;

    if (currentMaskData && outCtx && offCtx) {
      // Aplicar máscara al frame
      const temp = document.createElement('canvas');
      temp.width = W;
      temp.height = H;
      const tctx = temp.getContext('2d');
      tctx.drawImage(offCanvas, 0, 0);
      tctx.globalCompositeOperation = 'destination-in';
      tctx.putImageData(currentMaskData, 0, 0);

      outCtx.clearRect(0, 0, W, H);

      // Distorsión horizontal
      const amp = parseFloat(intensity.value) / 30;
      const slice = 4;
      let timeOffset = performance.now() / 400;
      for (let x = 0; x < W; x += slice) {
        const dx = Math.round(Math.sin((x / 20) + timeOffset) * amp * 10);
        const col = tctx.getImageData(x, 0, slice, H);
        const newX = Math.max(0, Math.min(W - slice, x + dx));
        outCtx.putImageData(col, newX, 0);
      }

      // Distorsión vertical
      const verticalTemp = document.createElement('canvas');
      verticalTemp.width = W;
      verticalTemp.height = H;
      const vctx = verticalTemp.getContext('2d');
      vctx.drawImage(out, 0, 0);

      const verticalTimeOffset = performance.now() / 300;
      for (let y = 0; y < H; y += slice) {
        const dy = Math.round(Math.sin((y / 30) + verticalTimeOffset) * amp * 8 * deltaTime * 60);
        const row = vctx.getImageData(0, y, W, slice);
        const newY = Math.max(0, Math.min(H - slice, y + dy));
        outCtx.putImageData(row, 0, newY);
      }

      // Overlay y tinte
      outCtx.globalAlpha = 0.4;
      outCtx.drawImage(offCanvas, 0, 0);
      outCtx.globalAlpha = 1.0;

      if (intensity.value > 1) {
        outCtx.fillStyle = `rgba(200,100,150,${intensity.value / 400})`;
        outCtx.fillRect(0, 0, W, H);
      }
    } else if (offCtx) {
      outCtx.drawImage(offCanvas, 0, 0);
    }

    requestAnimationFrame(frameLoop);
  }

  startBtn.onclick = async () => {
    if (running) return;
    await setupCamera();
    await loadModel();
    running = true;
    prevTime = performance.now();
    frameCount = 0;
    requestAnimationFrame(frameLoop);
    startBtn.textContent = 'Experiencia Activa';
    startBtn.style.opacity = '0.7';
  };
  
  stopBtn.onclick = () => {
    running = false;
    currentMaskData = null;
    frameCount = 0;
    outCtx.clearRect(0, 0, W, H);
    if (video.srcObject && offCtx) {
      offCtx.save();
      offCtx.scale(-1, 1);
      offCtx.drawImage(video, -W, 0, W, H);
      offCtx.restore();
      outCtx.drawImage(offCanvas, 0, 0);
    }
    startBtn.textContent = 'Iniciar Experiencia';
    startBtn.style.opacity = '1';
  };

  // Inicializar offCtx después de defaults
  if (offCanvas) {
    offCtx = offCanvas.getContext('2d');
  }
})();
</script>
</body>
</html>
