<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Espejo Distorsionado</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
    #startBtn {
      position: absolute;
      top: 20px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.8);
      border: none;
      font-size: 18px;
      cursor: pointer;
      border-radius: 5px;
      z-index: 10;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
<button id="startBtn">Activar Cámara</button>

<script id="fragShader" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tex0;
uniform vec2 resolution;
uniform float time;

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;

  // Distorsión ondulada (amplitud reducida para menos difuminado)
  float distortionX = 0.02 * sin(uv.y * 10.0 + time * 2.0);
  float distortionY = 0.02 * cos(uv.x * 10.0 + time * 1.5);
  uv.x = clamp(uv.x + distortionX, 0.0, 1.0);
  uv.y = clamp(uv.y + distortionY, 0.0, 1.0);

  vec3 col = texture2D(tex0, uv).rgb;
  gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
let cam;
let shaderProgram;
let started = false;

function setup() {
  let cnv = createCanvas(windowWidth, windowHeight, WEBGL);
  cnv.style('display', 'block');
  cnv.position(0, 0); // Asegurar posición absoluta en la esquina superior izquierda

  // Proyección ortográfica para cubrir exactamente el viewport (evita distorsiones de perspectiva)
  ortho(-width / 2, width / 2, height / 2, -height / 2, 0, 1);

  let vertSource = `
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;
    uniform mat4 uProjectionMatrix;
    uniform mat4 uModelViewMatrix;
    void main() {
      vTexCoord = aTexCoord;
      gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
    }
  `;

  shaderProgram = createShader(vertSource, document.getElementById("fragShader").textContent);
  noStroke();

  let btn = select("#startBtn");
  btn.mousePressed(startCamera);
}

function startCamera() {
  const constraints = {
    video: {
      facingMode: { exact: "environment" }, // cámara trasera
      width: { ideal: windowWidth },
      height: { ideal: windowHeight }
    },
    audio: false
  };

  cam = createCapture(constraints, () => {
    console.log("Cámara trasera activada");
    cam.play(); // Asegurar que el video se reproduzca inmediatamente
  });
  cam.size(windowWidth, windowHeight);
  cam.hide();
  cam.id('cameraVideo'); // ID para debugging si es necesario

  started = true;
  select("#startBtn").hide();
}

function draw() {
  if (!started || !cam || !cam.loadedmetadata) {
    background(0);
    return;
  }

  background(0); // Limpiar el fondo en cada frame
  resetMatrix(); // Resetear transformaciones

  // Usar plane() en lugar de rect() para un quad full-screen en WEBGL (mejor para texturas)
  shader(shaderProgram);
  shaderProgram.setUniform("tex0", cam);
  shaderProgram.setUniform("resolution", [width, height]);
  shaderProgram.setUniform("time", millis() / 1000.0);

  // Dibujar el plane centrado en el origen, cubriendo todo el viewport
  plane(width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  if (started && cam) {
    cam.size(windowWidth, windowHeight);
    // Reaplicar proyección ortográfica
    ortho(-width / 2, width / 2, height / 2, -height / 2, 0, 1);
  }
}

</script>
</body>
</html>
