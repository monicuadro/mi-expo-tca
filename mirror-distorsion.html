<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Espejo Distorsionado</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    canvas {
      display: block;
    }
    #startBtn {
      position: absolute;
      top: 20px;
      padding: 10px 20px;
      background: rgba(255,255,255,0.8);
      border: none;
      font-size: 18px;
      cursor: pointer;
      border-radius: 5px;
      z-index: 10;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
</head>
<body>
<button id="startBtn">Activar Cámara</button>

<script id="fragShader" type="x-shader/x-fragment">
#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tex0;
uniform vec2 resolution;
uniform float time;

void main() {
  vec2 uv = gl_FragCoord.xy / resolution.xy;

  // Distorsión ondulada
  uv.x += 0.05 * sin(uv.y * 10.0 + time * 2.0);
  uv.y += 0.05 * cos(uv.x * 10.0 + time * 1.5);

  vec3 col = texture2D(tex0, uv).rgb;
  gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
let cam;
let shaderProgram;
let started = false;

function setup() {
  let cnv = createCanvas(windowWidth, windowHeight, WEBGL);
  cnv.style('display', 'block');

  // Vertex shader corregido: incluye matrices de proyección y modelo para renderizado correcto en WEBGL
  let vertSource = `
    attribute vec3 aPosition;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;
    uniform mat4 uProjectionMatrix;
    uniform mat4 uModelViewMatrix;
    void main() {
      vTexCoord = aTexCoord;
      gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aPosition, 1.0);
    }
  `;

  shaderProgram = createShader(vertSource, document.getElementById("fragShader").textContent);
  noStroke();

  let btn = select("#startBtn");
  btn.mousePressed(startCamera);
}

function startCamera() {
  const constraints = {
    video: {
      facingMode: { exact: "environment" } // cámara trasera
    },
    audio: false
  };

  cam = createCapture(constraints, () => {
    console.log("Cámara trasera activada");
  });
  cam.size(windowWidth, windowHeight);
  cam.hide();

  started = true;
  select("#startBtn").hide();
}

function draw() {
  if (!started) {
    background(0);
    return;
  }

  // Resetear matrices para un quad full-screen
  resetMatrix();

  shader(shaderProgram);
  shaderProgram.setUniform("tex0", cam);
  shaderProgram.setUniform("resolution", [width, height]);
  shaderProgram.setUniform("time", millis() / 1000.0);

  rect(-width/2, -height/2, width, height);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  if (started && cam) {
    cam.size(windowWidth, windowHeight);
  }
}

</script>
</body>
</html>
