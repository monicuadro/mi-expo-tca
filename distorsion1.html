<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Espejo Distorsionado: Reflexión y Dismorfia Corporal</title>
<style>
  body {
    margin: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #0f0f23 0%, #1a0d2e 50%, #2d1b69 100%);
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
  }

  h1 {
    font-size: 1.8rem;
    font-weight: 300;
    margin: 20px 0 10px;
    text-align: center;
    letter-spacing: 1px;
    color: #e0d7ff;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }

  p.description {
    max-width: 600px;
    text-align: center;
    font-size: 1rem;
    line-height: 1.5;
    margin: 0 0 20px;
    color: #d1d5db;
    opacity: 0.9;
  }

  #stage {
    position: relative;
    width: 480px;
    height: 640px;
    margin: 20px 0;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 
      0 10px 30px rgba(139, 92, 246, 0.3),
      0 4px 20px rgba(0,0,0,0.4),
      inset 0 2px 4px rgba(255,255,255,0.1);
    transition: box-shadow 0.3s ease;
  }

  #stage:hover {
    box-shadow: 
      0 15px 40px rgba(139, 92, 246, 0.4),
      0 6px 25px rgba(0,0,0,0.5),
      inset 0 2px 4px rgba(255,255,255,0.1);
  }

  video, canvas {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 16px;
  }

  #controls {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 16px;
    align-items: center;
    width: 100%;
    max-width: 480px;
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
    width: 100%;
    align-items: center;
  }

  label {
    font-size: 0.95rem;
    color: #e0d7ff;
    font-weight: 500;
    margin-bottom: 4px;
  }

  #intensity {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.1);
    outline: none;
    -webkit-appearance: none;
  }

  #intensity::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #8B5CF6, #A78BFA);
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
  }

  #intensity::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: linear-gradient(135deg, #8B5CF6, #A78BFA);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
  }

  .btn-group {
    display: flex;
    gap: 12px;
    width: 100%;
    justify-content: center;
  }

  .btn {
    padding: 12px 24px;
    border-radius: 12px;
    border: none;
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    min-width: 140px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    position: relative; /* Para loading spinner */
    overflow: hidden;
  }

  .btn.loading {
    pointer-events: none;
    opacity: 0.7;
  }

  .btn.loading::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 16px;
    top: 50%;
    left: 50%;
    margin-left: -8px;
    margin-top: -8px;
    border: 2px solid transparent;
    border-top: 2px solid currentColor;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  #start {
    background: linear-gradient(135deg, #8B5CF6, #A78BFA);
    color: #fff;
  }

  #start:hover:not(.loading) {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
  }

  #stop {
    background: linear-gradient(135deg, #6B7280, #9CA3AF);
    color: #fff;
  }

  #stop:hover:not(.loading) {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(107, 114, 128, 0.4);
  }

  .btn:active {
    transform: translateY(0);
  }

  @media (max-width: 600px) {
    #stage {
      width: 100%;
      max-width: 480px;
      height: auto;
      aspect-ratio: 480/640;
    }
    
    h1 {
      font-size: 1.5rem;
    }
    
    .btn-group {
      flex-direction: column;
    }
  }
</style>
</head>
<body>
<h1>Espejo Distorsionado</h1>
<p class="description">
  Esta experiencia te invita a mirarte en un espejo digital que distorsiona tu reflejo, explorando la dismorfia corporal. Ajusta la intensidad para ver cómo la percepción de tu imagen puede alterarse, recordándonos cómo el cuerpo se ve a través de lentes subjetivos. Usa la cámara frontal para una reflexión íntima y reflexiva.
</p>

<div id="stage">
  <video id="video" autoplay playsinline></video>
  <canvas id="out"></canvas>
</div>

<div id="controls">
  <div class="control-group">
    <label for="intensity">Intensidad de Distorsión (0-100)</label>
    <input id="intensity" type="range" min="0" max="100" value="0">
  </div>
  
  <div class="btn-group">
    <button id="start" class="btn">Iniciar Experiencia</button>
    <button id="stop" class="btn">Restaurar Espejo</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.min.js"></script>
<script>
(async function(){
  const video = document.getElementById('video');
  const out = document.getElementById('out');
  const intensity = document.getElementById('intensity');
  const startBtn = document.getElementById('start');
  const stopBtn = document.getElementById('stop');

  const W = 480, H = 640;
  out.width = W; out.height = H;

  let net = null, running = false, 
      offCanvas = document.createElement('canvas'),
      maskCanvas = document.createElement('canvas'),
      bodyCanvas = document.createElement('canvas'), // Nuevo: para el cuerpo enmascarado base
      distortedBodyCanvas = document.createElement('canvas'); // Nuevo: para aplicar distorsiones al cuerpo
  
  // Inicializar canvases reutilizables
  offCanvas.width = W; offCanvas.height = H;
  maskCanvas.width = W; maskCanvas.height = H;
  bodyCanvas.width = W; bodyCanvas.height = H;
  distortedBodyCanvas.width = W; distortedBodyCanvas.height = H;
  
  const offCtx = offCanvas.getContext('2d');
  const maskCtx = maskCanvas.getContext('2d');
  const bodyCtx = bodyCanvas.getContext('2d');
  const distortedBodyCtx = distortedBodyCanvas.getContext('2d');
  const outCtx = out.getContext('2d');

  let lastSegmentationTime = 0;
  const SEGMENTATION_INTERVAL = 150; // Milisegundos entre segmentaciones
  let cachedMask = null; // Reutilizar máscara

  async function setupCamera(){
    try {
      // Optimizaciones para mobile
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: 'user', 
          width: { ideal: W }, 
          height: { ideal: H },
          frameRate: { ideal: 30, max: 30 }
        }, 
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      
      // Esperar a que el video tenga frames disponibles antes de proceder
      return new Promise((resolve) => {
        const checkReady = () => {
          if (video.readyState >= 2) { // HAVE_CURRENT_DATA
            resolve();
          } else {
            setTimeout(checkReady, 100);
          }
        };
        checkReady();
      });
    } catch (err) {
      throw new Error('No se pudo acceder a la cámara. Asegúrate de permitir el acceso.');
    }
  }

  async function loadModel(){
    try {
      // Usar multiplier 0.5 (compatible y equilibrado para mobile; 0.25 no es soportado en todas las versiones)
      net = await bodyPix.load({
        architecture: 'MobileNetV1', 
        outputStride: 16, 
        multiplier: 0.5
      });
    } catch (err) {
      throw new Error('Error al cargar el modelo de IA. Verifica tu conexión a internet.');
    }
  }

  function applyDistortion(targetCtx, sourceCanvas, isHorizontal = true) {
    const sourceCtx = sourceCanvas.getContext('2d'); // Usar contexto del sourceCanvas pasado
    const amp = parseFloat(intensity.value) / 30;
    const slice = 8; // Mayor slice para velocidad
    const time = performance.now();
    
    if (isHorizontal) {
      for (let x = 0; x < W; x += slice) {
        const dx = Math.round(Math.sin((x / 20) + time / 400) * amp * 10);
        const newX = Math.max(0, Math.min(W - slice, x + dx));
        const col = sourceCtx.getImageData(x, 0, slice, H);
        targetCtx.putImageData(col, newX, 0);
      }
    } else {
      for (let y = 0; y < H; y += slice) {
        const dy = Math.round(Math.sin((y / 30) + time / 300) * amp * 8);
        const newY = Math.max(0, Math.min(H - slice, y + dy));
        const row = sourceCtx.getImageData(0, y, W, slice);
        targetCtx.putImageData(row, 0, newY);
      }
    }
  }

  async function frameLoop() {
    if (!running || !net || video.readyState < 2) return;
    
    // Flip horizontal para efecto espejo
    offCtx.save();
    offCtx.scale(-1, 1);
    offCtx.drawImage(video, -W, 0, W, H);
    offCtx.restore();

    const now = performance.now();
    
    // Segmentación solo cada INTERVALO ms
    if (now - lastSegmentationTime > SEGMENTATION_INTERVAL || !cachedMask) {
      try {
        const segmentation = await net.segmentPerson(offCanvas, { 
          internalResolution: 'low', 
          segmentationThreshold: 0.7 
        });
        cachedMask = bodyPix.toMask(segmentation, {r:0,g:0,b:0,a:0}, {r:0,g:0,b:0,a:255});
        maskCtx.putImageData(cachedMask, 0, 0);
        lastSegmentationTime = now;
      } catch (e) {
        console.warn('Error en segmentación:', e);
        // Reutilizar máscara anterior si existe
        if (cachedMask) {
          maskCtx.putImageData(cachedMask, 0, 0);
        } else {
          // Si no hay máscara, saltar distorsión
          requestAnimationFrame(frameLoop);
          return;
        }
      }
    }

    // Preparar cuerpo enmascarado (base para distorsiones)
    bodyCtx.clearRect(0, 0, W, H);
    bodyCtx.drawImage(offCanvas, 0, 0);
    bodyCtx.globalCompositeOperation = 'destination-in';
    bodyCtx.drawImage(maskCanvas, 0, 0);

    // Aplicar distorsiones solo al cuerpo
    distortedBodyCtx.clearRect(0, 0, W, H);
    distortedBodyCtx.drawImage(bodyCanvas, 0, 0); // Copia base enmascarada

    // Distorsión horizontal al cuerpo
    applyDistortion(distortedBodyCtx, bodyCanvas, true);

    // Distorsión vertical al resultado horizontal (todavía solo cuerpo)
    applyDistortion(distortedBodyCtx, distortedBodyCanvas, false);

    // Componer en output: fondo + cuerpo distorsionado
    outCtx.clearRect(0, 0, W, H);
    outCtx.globalAlpha = 0.4; // Opacidad sutil para el fondo
    outCtx.drawImage(offCanvas, 0, 0);
    outCtx.globalAlpha = 1.0;
    outCtx.drawImage(distortedBodyCanvas, 0, 0); // Superponer cuerpo distorsionado

    // Overlay si intensidad alta
    if (parseFloat(intensity.value) > 50) {
      outCtx.fillStyle = `rgba(200,100,150,${intensity.value / 400})`;
      outCtx.globalCompositeOperation = 'overlay';
      outCtx.fillRect(0, 0, W, H);
      outCtx.globalCompositeOperation = 'source-over';
    }

    requestAnimationFrame(frameLoop);
  }

  // Manejo de eventos con estados de loading
  startBtn.onclick = async () => {
    if (running) return;
    startBtn.classList.add('loading');
    startBtn.textContent = '';
    try {
      await setupCamera();
      await loadModel();
      // Pequeño delay para asegurar que todo esté listo
      await new Promise(resolve => setTimeout(resolve, 500));
      running = true;
      frameLoop();
      startBtn.textContent = 'Experiencia Activa';
      startBtn.classList.remove('loading');
      startBtn.style.opacity = '0.7';
      stopBtn.disabled = false; // Habilitar stop
    } catch (e) {
      console.error('Error iniciando:', e);
      startBtn.textContent = `Error: ${e.message}`;
      startBtn.classList.remove('loading');
      setTimeout(() => {
        startBtn.textContent = 'Iniciar Experiencia';
      }, 3000);
      // Limpiar stream si se inició parcialmente
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
    }
  };
  
  stopBtn.onclick = () => {
    if (!running) return;
    stopBtn.classList.add('loading');
    stopBtn.textContent = '';
    setTimeout(() => {
      running = false;
      const stream = video.srcObject;
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        video.srcObject = null;
      }
      outCtx.clearRect(0, 0, W, H);
      cachedMask = null;
      startBtn.textContent = 'Iniciar Experiencia';
      startBtn.style.opacity = '1';
      stopBtn.textContent = 'Restaurar Espejo';
      stopBtn.classList.remove('loading');
      stopBtn.disabled = true; // Deshabilitar hasta nuevo start
    }, 300);
  };

  // Deshabilitar stop inicialmente
  stopBtn.disabled = true;

  // Listener para intensidad
  intensity.addEventListener('input', () => {
    // Actualización en tiempo real en frameLoop
  });
})();
</script>
</body>
</html>
