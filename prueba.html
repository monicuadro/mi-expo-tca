<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Dismorfia – Obra Interactiva</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: sans-serif;
    }

    video, canvas {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }

    /* Modal de advertencia */
    .modal {
      position: fixed;
      z-index: 2000;
      left: 0; top: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .modal-content {
      background: #111;
      padding: 20px;
      border-radius: 10px;
      max-width: 500px;
      text-align: center;
      box-shadow: 0 0 15px rgba(255,255,255,0.2);
    }
    .modal-content h2 { margin-top: 0; color: #f33; }
    .modal-content ul { text-align: left; }
    .modal-content button {
      margin: 10px;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }
    .accept { background: #0a0; color: white; }
    .cancel { background: #333; color: white; }

    /* Botón de sonido */
    #sonido {
      position: fixed;
      top: 50%;
      left: 10px;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 20px;
      padding: 12px;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1500;
      user-select: none;
    }
    #sonido:hover {
      background: rgba(255,255,255,0.2);
    }
  </style>
</head>
<body>
  <!-- Modal de advertencia -->
  <div id="warningModal" class="modal">
    <div class="modal-content">
      <h2>⚠️ Aviso de advertencia</h2>
      <p>Esta obra utiliza cámara y sonido en tiempo real.  
      Las distorsiones visuales y auditivas pueden resultar perturbadoras.</p>
      <ul>
        <li>No recomendada para personas con <strong>epilepsia fotosensible</strong> o <strong>ansiedad severa</strong>.</li>
        <li>Se recomienda interactuar en un <strong>espacio tranquilo</strong>, con <strong>volumen moderado</strong>.</li>
        <li>El uso de la cámara es opcional, pero sin ella la obra no funcionará de forma completa.</li>
      </ul>
      <div>
        <button class="accept" onclick="closeModal()">Acepto</button>
        <button class="cancel" onclick="window.location.href='https://google.com'">Cancelar</button>
      </div>
    </div>
  </div>

  <!-- Obra visual -->
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <!-- Botón de paisaje sonoro -->
  <div id="sonido" onclick="toggleSoundscape()">▶</div>

  <!-- Script modal -->
  <script>
    function closeModal() {
      document.getElementById('warningModal').style.display = 'none';
      startCamera();
    }
  </script>

  <!-- Script obra visual -->
  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function startCamera() {
      navigator.mediaDevices.getUserMedia({ video: true, audio: false })
        .then(stream => { video.srcObject = stream; })
        .catch(err => console.error("Error cámara:", err));
    }

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function draw() {
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      let data = imageData.data;
      // Distorsión tipo onda
      for (let y = 0; y < canvas.height; y+=2) {
        for (let x = 0; x < canvas.width; x+=2) {
          let index = (y * canvas.width + x) * 4;
          let offset = Math.sin(y / 20) * 20;
          let newX = (x + offset) % canvas.width;
          if (newX < 0) newX += canvas.width;
          let newIndex = (y * canvas.width + Math.floor(newX)) * 4;
          data[index] = data[newIndex];
          data[index+1] = data[newIndex+1];
          data[index+2] = data[newIndex+2];
        }
      }
      ctx.putImageData(imageData, 0, 0);
      requestAnimationFrame(draw);
    }
    video.addEventListener('play', () => { draw(); });
  </script>

  <!-- Script paisaje sonoro complejo -->
  <script>
    let audioCtx, masterGain, convolver, distort, isPlaying = false, timeouts = [];
    const fases = ["Contención", "Crisis", "Fragmentación", "Distorsión", "Resolución"];
    let faseIndex = 0;

    function initAudio(){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.35;

        // Reverberación
        convolver = audioCtx.createConvolver();
        const length = audioCtx.sampleRate * 3;
        const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
        for (let c=0;c<2;c++){
          const data = impulse.getChannelData(c);
          for (let i=0;i<length;i++){
            data[i] = (Math.random()*2-1) * Math.pow(1-i/length,2);
          }
        }
        convolver.buffer = impulse;

        // Distorsión ligera
        distort = audioCtx.createWaveShaper();
        distort.curve = makeDistortionCurve(400);
        distort.oversample = '4x';

        masterGain.connect(audioCtx.destination);
        convolver.connect(distort);
        distort.connect(masterGain);
      }
    }

    function makeDistortionCurve(amount){
      let k = typeof amount === 'number' ? amount : 50,
          n_samples = 44100,
          curve = new Float32Array(n_samples),
          deg = Math.PI / 180;
      for (let i = 0; i < n_samples; ++i) {
        let x = i * 2 / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
      }
      return curve;
    }

    function updateButton(text){
      document.getElementById("sonido").textContent = text;
    }

    function stopSoundscape(){
      isPlaying = false;
      timeouts.forEach(t=>clearTimeout(t));
      timeouts=[];
      updateButton("▶");
    }

    function toggleSoundscape(){
      if (isPlaying){
        stopSoundscape();
      } else {
        startSoundscape();
      }
    }

    function startSoundscape(){
      initAudio();
      stopSoundscape();
      isPlaying = true;
      faseIndex = 0;

      function connectFX(node){
        node.connect(convolver);
        node.connect(masterGain);
      }

      function playDrone(freq, start, dur, vol=0.08, type="sine"){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const panner = audioCtx.createStereoPanner();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(panner);
        connectFX(panner);
        panner.pan.setValueAtTime(-1, start);
        panner.pan.linearRampToValueAtTime(1, start+dur);
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(vol, start+2);
        gain.gain.linearRampToValueAtTime(0.0001, start+dur);
        osc.start(start);
        osc.stop(start+dur);
      }

      function heartbeat(time, intensity=0.15){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const panner = audioCtx.createStereoPanner();
        osc.frequency.value = 60;
        osc.type = 'sine';
        osc.connect(gain);
        gain.connect(panner);
        connectFX(panner);
        panner.pan.setValueAtTime(Math.random()*2-1, time);
        gain.gain.setValueAtTime(intensity, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time+0.1);
        osc.start(time);
        osc.stop(time+0.12);
      }

      function noiseBreath(start, dur){
        const noise = audioCtx.createBufferSource();
        const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.5;
        noise.buffer = buffer;
        const gain = audioCtx.createGain();
        const panner = audioCtx.createStereoPanner();
        noise.connect(gain);
        gain.connect(panner);
        connectFX(panner);
        let t=start;
        while (t<start+dur){
          let panVal = (Math.random()*2-1);
          panner.pan.setValueAtTime(panVal, t);
          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(0.25, t+0.5);
          gain.gain.linearRampToValueAtTime(0, t+1.5);
          t+=2;
        }
        noise.start(start);
        noise.stop(start+dur);
      }

      function metallicPing(time){
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        const panner = audioCtx.createStereoPanner();
        osc.type = 'square';
        osc.frequency.value = 1000 + Math.random()*2000;
        osc.connect(gain);
        gain.connect(panner);
        connectFX(panner);
        panner.pan.setValueAtTime(Math.random()*2-1, time);
        gain.gain.setValueAtTime(0.15, time);
        gain.gain.exponentialRampToValueAtTime(0.0001, time+1.5);
        osc.start(time);
        osc.stop(time+1.5);
      }

      // Timeline de 5 minutos
      const faseDur = 60; // cada fase 1 min

      fases.forEach((fase, i)=>{
        timeouts.push(setTimeout(()=>{
          if (!isPlaying) return;
          updateButton(fase);
          const t = audioCtx.currentTime;
          if (fase==="Contención"){
            playDrone(60, t, faseDur, 0.08, "sine");
            for (let j=0;j<20;j++){heartbeat(t+j*3,0.08);}        
          } else if (fase==="Crisis"){
            playDrone(70, t, faseDur, 0.1, "sine");
            for (let j=0;j<50;j++){heartbeat(t+j*1.2,0.2);}        
            noiseBreath(t+2,faseDur-2);
          } else if (fase==="Fragmentación"){
            for (let j=0;j<30;j++){ metallicPing(t+Math.random()*faseDur); }
            noiseBreath(t, faseDur);
          } else if (fase==="Distorsión"){
            playDrone(100, t, faseDur, 0.09, "triangle");
            for (let j=0;j<40;j++){heartbeat(t+j*1.5,0.25);}        
            for (let j=0;j<20;j++){ metallicPing(t+Math.random()*faseDur); }
          } else if (fase==="Resolución"){
            playDrone(130, t, faseDur, 0.05, "triangle");
            playDrone(261.6, t, faseDur, 0.03, "sine");
          }
        }, i*faseDur*1000));
      });

      // Fin de experiencia
      timeouts.push(setTimeout(()=>{
        stopSoundscape();
        updateButton("✦");
      }, fases.length*faseDur*1000));
    }
  </script>
</body>
</html>
