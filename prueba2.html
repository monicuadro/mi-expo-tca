<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Espejo Distorsionado + Paisaje Sonoro</title>
    <style>
        /* ====== Estilos base (fusionados) ====== */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #000;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        video#video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        canvas#canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Controles de distorsión */
        #controls {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            text-align: center;
            background: rgba(75, 0, 130, 0.7);
            padding: 8px;
            border-radius: 10px;
            width: 90%;
            max-width: 350px;
            transition: opacity 0.3s;
            box-shadow: 0 4px 15px rgba(75, 0, 130, 0.3);
        }
        #controls.hidden { opacity: 0; pointer-events: none; }
        #intensity { width: 100%; margin: 3px 0; height: 22px; }
        #distorsion-btn, #reset, #presets button {
            background: linear-gradient(to right, #4B0082, #2F004F);
            color: #fff;
            border: none;
            padding: 6px 8px;
            margin: 1px;
            border-radius: 8px;
            font-size: 12px;
            touch-action: manipulation;
            min-width: 60px;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        #distorsion-btn { background: linear-gradient(to right, #7CFC00, #32CD32); }
        #distorsion-btn.active { background: linear-gradient(to right, #32CD32, #228B22); transform: scale(1.05); box-shadow: 0 2px 10px rgba(124,252,0,0.5); }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(75, 0, 130, 0.7);
            padding: 12px;
            border-radius: 10px;
            z-index: 15;
            display: none;
            text-align: center;
            box-shadow: 0 4px 15px rgba(75, 0, 130, 0.3);
        }
        #loading, #error {
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 25; font-size: 16px; text-align:center; background: rgba(75,0,130,0.8);
            padding: 12px; border-radius: 10px; color: #fff;
        }
        #fps { position: absolute; top: 10px; right: 10px; font-size: 11px; z-index: 12; background: rgba(75,0,130,0.6); padding:4px; border-radius:5px; color:#fff; }
        #presets { display:flex; flex-wrap:wrap; justify-content:space-evenly; margin-top:3px; gap:2px; }

        /* Botón de sonido del paisaje sonoro */
        #sonido {
            position: fixed;
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 6px;
            border-radius: 50%;
            font-family: sans-serif;
            font-size: 12px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000; /* arriba de todo */
            text-align: center;
        }
        #sonido:hover { background: rgba(255,255,255,0.1); }

        @media (max-width: 768px) {
            #controls { width: 95%; padding: 6px; bottom: 70px; max-width: none; }
            #instructions { font-size: 13px; padding: 10px; }
            body { font-size: 15px; }
            #presets button, #distorsion-btn { padding: 6px 6px; font-size: 12px; min-width: 55px; margin: 0; }
            #presets { flex-direction: row; flex-wrap: nowrap; justify-content: space-evenly; margin-top: 2px; gap:1px; }
        }
        @media (orientation: landscape) and (max-height: 500px) {
            #controls { bottom: 45px; padding: 4px; opacity: 0.8; width:95%; }
            #distorsion-btn, #reset, #presets button { padding: 5px 6px; min-width: 50px; font-size: 11px; }
            #presets { margin-top: 1px; gap:1px; flex-wrap: nowrap; justify-content: space-around; }
            #intensity { height: 20px; margin: 2px 0; }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>

        <div id="instructions">
            <h2>Espejo Distorsionado </h2>
            <p>Explora distorsiones en tu reflejo para reflexionar sobre la dismorfia corporal. Usa la cámara frontal.</p>
            <p><strong>Efecto:</strong> Ondas + bulge (efectos variados). Activa con el botón "Distorsión".</p>
            <button onclick="closeInstructions()" style="background: linear-gradient(to right, #4B0082, #2F004F); border: none; color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px;">Iniciar Experiencia</button>
        </div>

        <div id="loading">Cargando cámara... Otorga permisos.</div>
        <div id="error" style="display: none;">
            <p>Error en cámara. Verifica permisos o HTTPS.</p>
            <button onclick="initCamera()" style="background: linear-gradient(to right, #4B0082, #2F004F); border: none; color: white; padding: 8px 12px; border-radius: 5px; font-size: 14px;">Reintentar</button>
        </div>
        <div id="fps">FPS: 0</div>

        <div id="controls">
            <label for="intensity" style="font-size: 14px;">Intensidad (0-100): <span id="value">0</span></label>
            <input type="range" id="intensity" min="0" max="100" value="0" step="1">
            <button id="distorsion-btn" onclick="toggleDistorsion()">Distorsión</button>
            <div id="presets">
                <button onclick="setIntensity(25)">Bajo</button>
                <button onclick="setIntensity(50)">Medio</button>
                <button onclick="setIntensity(75)">Alto</button>
                <button onclick="setIntensity(100)">Intenso</button>
                <button id="reset" onclick="resetDistortion()">Reset</button>
            </div>
        </div>
    </div>

    <!-- Botón flotante del paisaje sonoro -->
    <div id="sonido" onclick="toggleSoundscape()">▶</div>

    <script>
        /* ====== Código de cámara + distorsión (adaptado) ====== */
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const intensitySlider = document.getElementById('intensity');
        const valueSpan = document.getElementById('value');
        const distorsionBtn = document.getElementById('distorsion-btn');
        const loading = document.getElementById('loading');
        const error = document.getElementById('error');
        const controls = document.getElementById('controls');
        const fpsEl = document.getElementById('fps');
        const instructions = document.getElementById('instructions');

        let distortionActive = false;
        let animationId;
        let stream;
        let lastTime = 0;
        let frameCount = 0;

        async function initCamera() {
            try {
                loading.style.display = 'block';
                error.style.display = 'none';
                const constraints = {
                    video: { 
                        facingMode: 'user', 
                        width: { ideal: window.innerWidth < 768 ? 480 : 640 }, 
                        height: { ideal: window.innerHeight < 768 ? 360 : 480 } 
                    }
                };
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    loading.style.display = 'none';
                    instructions.style.display = 'block';
                    video.play();
                    render();
                };
            } catch (err) {
                loading.style.display = 'none';
                error.style.display = 'block';
                console.error('Error cámara:', err);
            }
        }

        function render(currentTime = 0) {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.save();
                ctx.scale(-1, 1); // espejo en canvas
                ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                ctx.restore();

                const intensity = parseInt(intensitySlider.value);
                if (distortionActive && intensity > 0) {
                    distortImage(intensity, currentTime * 0.001);
                }

                // FPS
                frameCount++;
                if (currentTime - lastTime >= 1000) {
                    fpsEl.textContent = `FPS: ${Math.round(frameCount * 1000 / (currentTime - lastTime))}`;
                    frameCount = 0;
                    lastTime = currentTime;
                }
            }
            animationId = requestAnimationFrame(render);
        }

        function distortImage(intensity, time) {
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let sourceData = new Uint8ClampedArray(imageData.data);
            let destData = new Uint8ClampedArray(sourceData.length);
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;

            for (let y=0;y<h;y++){
                for (let x=0;x<w;x++){
                    let dx = Math.sin(y * 0.02 + time * 2) * (intensity/100) * 8;
                    let dy = Math.cos(x * 0.015 + time * 3) * (intensity/100) * 6;
                    const bulgeDist = Math.sqrt((x - cx)**2 + (y - cy)**2);
                    if (bulgeDist < 150) {
                        const bulgeFactor = (150 - bulgeDist) / 150 * (intensity/100) * 0.03;
                        dx += (x - cx) * bulgeFactor;
                        dy += (y - cy) * bulgeFactor;
                    }
                    let srcX = w - (x + dx);
                    let srcY = y + dy;
                    srcX = Math.max(0, Math.min(w-1, srcX));
                    srcY = Math.max(0, Math.min(h-1, srcY));

                    const x1 = Math.floor(srcX), y1 = Math.floor(srcY);
                    const x2 = Math.min(x1+1, w-1), y2 = Math.min(y1+1, h-1);
                    const fx = srcX - x1, fy = srcY - y1;
                    const i11 = (y1*w + x1)*4; const i12 = (y1*w + x2)*4;
                    const i21 = (y2*w + x1)*4; const i22 = (y2*w + x2)*4;

                    for (let c=0;c<3;c++){
                        const p11 = sourceData[i11 + c];
                        const p12 = sourceData[i12 + c];
                        const p21 = sourceData[i21 + c];
                        const p22 = sourceData[i22 + c];
                        const interp = p11*(1-fx)*(1-fy) + p12*fx*(1-fy) + p21*(1-fx)*fy + p22*fx*fy;
                        destData[(y*w + x)*4 + c] = Math.round(interp);
                    }
                    destData[(y*w + x)*4 + 3] = 255;
                }
            }

            imageData.data.set(destData);
            ctx.putImageData(imageData, 0, 0);
        }

        intensitySlider.addEventListener('input', (e)=>{ valueSpan.textContent = e.target.value; });

        function toggleDistorsion(){
            distortionActive = !distortionActive;
            distorsionBtn.textContent = distortionActive ? 'Desactivar Distorsión' : 'Distorsión';
            distorsionBtn.classList.toggle('active');
        }
        function setIntensity(val){ intensitySlider.value = val; valueSpan.textContent = val; }
        function resetDistortion(){ setIntensity(0); distortionActive = false; distorsionBtn.textContent = 'Distorsión'; distorsionBtn.classList.remove('active'); }
        function closeInstructions(){ instructions.style.display = 'none'; controls.classList.remove('hidden'); }

        window.addEventListener('orientationchange', ()=>{ if (window.innerHeight < 500){ controls.classList.add('hidden'); setTimeout(()=>controls.classList.remove('hidden'),1000); } });
        window.addEventListener('beforeunload', ()=>{ if (stream) stream.getTracks().forEach(t=>t.stop()); cancelAnimationFrame(animationId); });
        if (/Mobi|Android/i.test(navigator.userAgent)){
            document.addEventListener('touchstart', ()=>{ if (!document.fullscreenElement){ document.documentElement.requestFullscreen().catch(()=>{}); } }, { once:true });
        }

        initCamera();

        /* ====== Código del Paisaje Sonoro (fusionado) ====== */
        let audioCtx, masterGain, convolver, distort, soundIsPlaying = false, soundTimeouts = [];
        const fases = ["Contención", "Crisis", "Fragmentación", "Distorsión", "Resolución"];
        let faseIndex = 0;

        function initAudio(){
            if (!audioCtx){
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioCtx.createGain(); masterGain.gain.value = 0.35;

                convolver = audioCtx.createConvolver();
                const length = audioCtx.sampleRate * 3;
                const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
                for (let c=0;c<2;c++){
                    const data = impulse.getChannelData(c);
                    for (let i=0;i<length;i++) data[i] = (Math.random()*2-1) * Math.pow(1-i/length,2);
                }
                convolver.buffer = impulse;

                distort = audioCtx.createWaveShaper();
                distort.curve = makeDistortionCurve(400);
                distort.oversample = '4x';

                // Cadena FX: fuentes -> convolver -> distort -> masterGain -> destination
                masterGain.connect(audioCtx.destination);
                convolver.connect(distort);
                distort.connect(masterGain);
            }
        }

        function makeDistortionCurve(amount){
            let k = typeof amount === 'number' ? amount : 50,
                n_samples = 44100,
                curve = new Float32Array(n_samples),
                deg = Math.PI/180;
            for (let i=0;i<n_samples;++i){
                let x = i*2/n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function updateSoundButton(text){ document.getElementById('sonido').textContent = text; }

        function stopSoundscape(){
            soundIsPlaying = false;
            soundTimeouts.forEach(t=>clearTimeout(t));
            soundTimeouts = [];
            updateSoundButton('▶');
        }

        function toggleSoundscape(){ if (soundIsPlaying) stopSoundscape(); else startSoundscape(); }

        function startSoundscape(){
            initAudio();
            stopSoundscape();
            soundIsPlaying = true;
            faseIndex = 0;

            function connectFX(node){ node.connect(convolver); node.connect(masterGain); }

            function playDrone(freq, start, dur, vol=0.08, type='sine'){
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner();
                osc.type = type; osc.frequency.value = freq;
                osc.connect(gain); gain.connect(panner); connectFX(panner);
                panner.pan.setValueAtTime(-1, start);
                panner.pan.linearRampToValueAtTime(1, start+dur);
                gain.gain.setValueAtTime(0, start);
                gain.gain.linearRampToValueAtTime(vol, start+2);
                gain.gain.linearRampToValueAtTime(0.0001, start+dur);
                osc.start(start); osc.stop(start+dur);
            }

            function heartbeat(time, intensity=0.15){
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner();
                osc.frequency.value = 60; osc.type = 'sine';
                osc.connect(gain); gain.connect(panner); connectFX(panner);
                panner.pan.setValueAtTime(Math.random()*2-1, time);
                gain.gain.setValueAtTime(intensity, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time+0.1);
                osc.start(time); osc.stop(time+0.12);
            }

            function noiseBreath(start, dur){
                const noise = audioCtx.createBufferSource();
                const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate*dur, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1)*0.5;
                noise.buffer = buffer;
                const gain = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner();
                noise.connect(gain); gain.connect(panner); connectFX(panner);
                let t = start;
                while (t < start + dur){
                    let panVal = (Math.random()*2-1);
                    panner.pan.setValueAtTime(panVal, t);
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.25, t+0.5);
                    gain.gain.linearRampToValueAtTime(0, t+1.5);
                    t += 2;
                }
                noise.start(start); noise.stop(start+dur);
            }

            function metallicPing(time){
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const panner = audioCtx.createStereoPanner();
                osc.type = 'square';
                osc.frequency.value = 1000 + Math.random()*2000;
                osc.connect(gain); gain.connect(panner); connectFX(panner);
                panner.pan.setValueAtTime(Math.random()*2-1, time);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.0001, time+1.5);
                osc.start(time); osc.stop(time+1.5);
            }

            // Timeline de 5 minutos (300s) con fases de 60s
            const faseDur = 60;
            fases.forEach((fase, i)=>{
                soundTimeouts.push(setTimeout(()=>{
                    if (!soundIsPlaying) return;
                    updateSoundButton(fase);
                    const t = audioCtx.currentTime;
                    if (fase === 'Contención'){
                        playDrone(60, t, faseDur, 0.08, 'sine');
                        for (let j=0;j<20;j++) heartbeat(t + j*3, 0.08);
                    } else if (fase === 'Crisis'){
                        playDrone(70, t, faseDur, 0.1, 'sine');
                        for (let j=0;j<50;j++) heartbeat(t + j*1.2, 0.2);
                        noiseBreath(t+2, faseDur-2);
                    } else if (fase === 'Fragmentación'){
                        for (let j=0;j<30;j++) metallicPing(t + Math.random()*faseDur);
                        noiseBreath(t, faseDur);
                    } else if (fase === 'Distorsión'){
                        playDrone(100, t, faseDur, 0.09, 'triangle');
                        for (let j=0;j<40;j++) heartbeat(t + j*1.5, 0.25);
                        for (let j=0;j<20;j++) metallicPing(t + Math.random()*faseDur);
                    } else if (fase === 'Resolución'){
                        playDrone(130, t, faseDur, 0.05, 'triangle');
                        playDrone(261.6, t, faseDur, 0.03, 'sine');
                    }
                }, i * faseDur * 1000));
            });

            // Fin de experiencia
            soundTimeouts.push(setTimeout(()=>{ stopSoundscape(); updateSoundButton('✦'); }, fases.length * faseDur * 1000));
        }

        // Cleanup audio on page unload
        window.addEventListener('beforeunload', ()=>{ stopSoundscape(); if (audioCtx && audioCtx.state !== 'closed'){ try{ audioCtx.close(); }catch(e){} } });
    </script>
</body>
</html>
