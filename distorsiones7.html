<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>Espejo Distorsionado: Reflexión y Dismorfia Corporal</title>
<style>
body {
margin: 0;
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
background: linear-gradient(135deg, #0f0f23 0%, #1a0d2e 50%, #2d1b69 100%);
color: #fff;
display: flex;
flex-direction: column;
align-items: center;
min-height: 100vh;
padding: 10px;
box-sizing: border-box;
}

h1 {
font-size: 1.5rem; /* Reducido para inmersión y mobile */
font-weight: 300;
margin: 10px 0 5px;
text-align: center;
letter-spacing: 1px;
color: #e0d7ff;
text-shadow: 
  0 2px 4px rgba(0,0,0,0.3),
  0 0 10px rgba(139, 92, 246, 0.5); /* Sombra translúcida púrpura para efecto etéreo */
}

p.description {
max-width: 600px;
text-align: center;
font-size: 0.9rem; /* Reducido para más inmersión */
line-height: 1.5;
margin: 0 0 15px;
color: #d1d5db;
opacity: 0.9;
}

#stage {
position: relative;
width: 100%;
max-width: 360px; /* Más compacto para mobile, sin ocupar todo el ancho */
height: auto;
aspect-ratio: 9/16; /* Ratio vertical portrait para evitar horizontal y estiramiento */
margin: 10px 0;
border-radius: 16px;
overflow: hidden;
box-shadow:
0 10px 30px rgba(139, 92, 246, 0.3),
0 4px 20px rgba(0,0,0,0.4),
inset 0 2px 4px rgba(255,255,255,0.1);
transition: box-shadow 0.3s ease;
}

#stage:hover {
box-shadow:
0 15px 40px rgba(139, 92, 246, 0.4),
0 6px 25px rgba(0,0,0,0.5),
inset 0 2px 4px rgba(255,255,255,0.1);
}

video, canvas {
position: absolute;
left: 0;
top: 0;
width: 100%;
height: 100%;
object-fit: cover; /* Cover para llenar sin estirar, recorta bordes si necesario para fluidez */
border-radius: 16px;
}

#controls {
margin-top: 15px;
display: flex;
flex-direction: column;
gap: 12px;
align-items: center;
width: 100%;
max-width: 360px;
}

.control-group {
display: flex;
flex-direction: column;
gap: 8px;
width: 100%;
align-items: center;
}

label {
font-size: 0.85rem; /* Reducido para mobile */
color: #e0d7ff;
font-weight: 500;
margin-bottom: 4px;
}

#intensity {
width: 100%;
height: 6px;
border-radius: 3px;
background: rgba(255,255,255,0.1);
outline: none;
-webkit-appearance: none;
}

#intensity::-webkit-slider-thumb {
-webkit-appearance: none;
appearance: none;
width: 20px;
height: 20px;
border-radius: 50%;
background: linear-gradient(135deg, #8B5CF6, #A78BFA);
cursor: pointer;
box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
}

#intensity::-moz-range-thumb {
width: 20px;
height: 20px;
border-radius: 50%;
background: linear-gradient(135deg, #8B5CF6, #A78BFA);
cursor: pointer;
border: none;
box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4);
}

.filter-buttons {
display: flex;
gap: 8px;
width: 100%;
justify-content: center;
flex-wrap: wrap;
}

.filter-btn {
padding: 8px 16px;
border-radius: 8px;
border: 1px solid rgba(255,255,255,0.2);
background: rgba(255,255,255,0.1);
color: #fff;
font-size: 0.8rem;
cursor: pointer;
transition: all 0.3s ease;
min-width: 80px;
}

.filter-btn.active,
.filter-btn:hover {
background: linear-gradient(135deg, #8B5CF6, #A78BFA);
border-color: #A78BFA;
transform: translateY(-1px);
box-shadow: 0 2px 8px rgba(139, 92, 246, 0.3);
}

.btn-group {
display: flex;
gap: 12px;
width: 100%;
justify-content: center;
}

.btn {
padding: 10px 20px; /* Ligeramente reducido para mobile */
border-radius: 12px;
border: none;
font-size: 0.85rem; /* Reducido para inmersión */
font-weight: 500;
cursor: pointer;
transition: all 0.3s ease;
text-transform: uppercase;
letter-spacing: 0.5px;
min-width: 120px; /* Ajustado */
box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}

#start {
background: linear-gradient(135deg, #8B5CF6, #A78BFA);
color: #fff;
}

#start:hover {
transform: translateY(-2px);
box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
}

#stop {
background: linear-gradient(135deg, #6B7280, #9CA3AF);
color: #fff;
}

#stop:hover {
transform: translateY(-2px);
box-shadow: 0 6px 16px rgba(107, 114, 128, 0.4);
}

.btn:active {
transform: translateY(0);
}

@media (max-width: 600px) {
#stage {
max-width: 320px; /* Aún más compacto para no ocupar tanto espacio */
aspect-ratio: 9/16; /* Mantiene vertical sin estiramiento */
}

h1 {
font-size: 1.2rem; /* Aún más pequeño en mobile */
}

p.description {
font-size: 0.8rem;
}

.filter-buttons {
flex-direction: column;
gap: 6px;
}

.filter-btn {
min-width: 100%;
font-size: 0.75rem;
}

.btn-group {
flex-direction: column;
}

.btn {
min-width: 100%;
}
}
</style>
</head>
<body>
<h1>Espejo Distorsionado</h1>
<p class="description">
Esta experiencia te invita a mirarte en un espejo digital que distorsiona tu reflejo, explorando la dismorfia corporal. Ajusta la intensidad y elige un filtro para ver cómo la percepción de tu imagen puede alterarse, recordándonos cómo el cuerpo se ve a través de lentes subjetivos. Usa la cámara frontal para una reflexión íntima y reflexiva.
</p>
<div id="stage">
<video id="video" autoplay playsinline></video>
<canvas id="out"></canvas>
</div>
<div id="controls">
<div class="control-group">
<label for="intensity">Intensidad de Distorsión (0-100)</label>
<input id="intensity" type="range" min="0" max="100" value="50"> <!-- Valor inicial 50 para efectos visibles -->
</div>
<div class="control-group">
<label>Tipo de Filtro Dismórfico</label>
<div class="filter-buttons">
<button class="filter-btn active" data-filter="bulge">Inflamación Ilusoria</button>
<button class="filter-btn" data-filter="pinch">Contracción Angustiosa</button>
<button class="filter-btn" data-filter="stretch">Estiramiento Eterno</button>
<button class="filter-btn" data-filter="ripple">Ondas Obsesivas</button>
</div>
</div>
<div class="btn-group">
<button id="start" class="btn">Iniciar Sombras</button>
<button id="stop" class="btn">Restaurar Esencia</button>
</div>
</div>
<script>
(async function(){
const video = document.getElementById('video');
const out = document.getElementById('out');
const intensity = document.getElementById('intensity');
const startBtn = document.getElementById('start');
const stopBtn = document.getElementById('stop');
const filterBtns = document.querySelectorAll('.filter-btn');
let currentFilter = 'bulge'; // Inicial con el primero activo

// Tamaños dinámicos y compactos: vertical portrait, ajustado para fluidez sin estiramiento
let W = Math.min(360, window.innerWidth * 0.9);
let H = W * (16 / 9); // Mantiene ratio 9:16 vertical (H > W)
out.width = W;
out.height = H;
let running = false;
const offCanvas = document.createElement('canvas');
offCanvas.width = W;
offCanvas.height = H;
const offCtx = offCanvas.getContext('2d');
const outCtx = out.getContext('2d');

let cameraSetup = false;

// Manejar botones de filtro (variados para dismorfia corporal: inflamación, contracción, estiramiento, ondas)
filterBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    filterBtns.forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentFilter = btn.dataset.filter;
  });
});

async function setupCamera() {
  if (cameraSetup) return;
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { 
        facingMode: 'user', 
        width: { ideal: W }, 
        height: { ideal: H },
        aspectRatio: { ideal: 9 / 16 } // Fuerza ratio vertical portrait para mobile
      },
      audio: false
    });
    video.srcObject = stream;
    await video.play();
    cameraSetup = true;
  } catch (err) {
    console.error('Error en cámara:', err);
    alert('No se pudo acceder a la cámara. Verifica permisos.');
  }
}

function applyFilter(time) {
  const amp = parseFloat(intensity.value) / 20;
  const slice = window.innerWidth < 600 ? 20 : 10; // Mayor slice en mobile para mayor fluidez (menos iteraciones)

  // Canvas temporal simple para distorsión (sin segmentación para simplicidad y velocidad)
  const distortCanvas = document.createElement('canvas');
  distortCanvas.width = W;
  distortCanvas.height = H;
  const distortCtx = distortCanvas.getContext('2d');
  distortCtx.drawImage(offCanvas, 0, 0);

  let dx = 0, dy = 0;

  // Bucle de distorsión optimizado (horizontal con componentes verticales para variedad en dismorfia)
  for (let x = 0; x < W; x += slice) {
    switch (currentFilter) {
      case 'bulge': // Inflamación: protuberancia en centro, como hinchazón corporal
        const centerX = W / 2;
        const distX = Math.abs(x - centerX) / (W / 2);
        dx = Math.cos(time / 700) * amp * 25 * (1 - distX); // Mayor amplitud para efecto dismórfico
        dy = Math.sin(time / 700) * amp * 20 * (1 - distX);
        break;
      case 'pinch': // Contracción: pellizco en centro, como reducción percibida del cuerpo
        const centerX2 = W / 2;
        const distX2 = Math.abs(x - centerX2) / (W / 2);
        dx = Math.cos(time / 700) * amp * -25 * (1 - distX2); // Negativo para contracción
        dy = Math.sin(time / 700) * amp * -20 * (1 - distX2);
        break;
      case 'stretch': // Estiramiento: elongación vertical con ondulación horizontal, como distorsión de proporciones
        dx = Math.sin((x / 25 + time / 600)) * amp * 20;
        dy = (x / W - 0.5) * amp * 40 + Math.sin(time / 800) * amp * 15; // Mayor dy para efecto vertical
        break;
      case 'ripple': // Ondas: ripples obsesivos, como inestabilidad corporal percibida
        dx = (Math.sin((x / 15 + time / 350)) + Math.cos((x / 20 + time / 450))) * amp * 22;
        dy = Math.sin((x / 18 + time / 400)) * amp * 18 + Math.cos(time / 500) * amp * 10; // Variado para fluidez
        break;
      default:
        dx = dy = 0;
    }

    const col = offCtx.getImageData(x, 0, slice, H);
    const clampedX = Math.max(0, Math.min(W - slice, x + dx));
    const clampedY = Math.max(0, Math.min(H - slice, dy));
    distortCtx.putImageData(col, clampedX, clampedY);
  }

  // Render final simple y fluido
  outCtx.clearRect(0, 0, W, H);
  outCtx.globalAlpha = 0.7; // Ligeramente más opaco para inmersión
  outCtx.drawImage(offCanvas, 0, 0);
  outCtx.globalAlpha = 1.0;
  outCtx.drawImage(distortCanvas, 0, 0);

  // Tinte sutil para dismorfia (opcional, ligero)
  if (intensity.value > 0) {
    outCtx.fillStyle = `rgba(200, 100, 150, ${intensity.value / 400})`; // Más translúcido
    outCtx.fillRect(0, 0, W, H);
  }
}

function frameLoop() {
  if (!running) return;

  const time = performance.now();

  // Flip horizontal simple para efecto espejo (sin complejidades)
  offCtx.save();
  offCtx.scale(-1, 1);
  offCtx.drawImage(video, -W, 0, W, H);
  offCtx.restore();

  // Aplicar filtro (sin segmentación para simplicidad y fluidez en todos los dispositivos)
  applyFilter(time);

  requestAnimationFrame(frameLoop);
}

startBtn.addEventListener('click', async () => {
  if (running) return;
  await setupCamera();
  running = true;
  frameLoop();
  startBtn.textContent = 'Sombras Iniciadas';
  startBtn.style.opacity = '0.7';
});

stopBtn.addEventListener('click', () => {
  running = false;
  outCtx.clearRect(0, 0, W, H);
  if (video.srcObject) {
    outCtx.save();
    outCtx.scale(-1, 1);
    outCtx.drawImage(video, -W, 0, W, H);
    outCtx.restore();
  }
  startBtn.textContent = 'Iniciar Sombras';
  startBtn.style.opacity = '1';
});

// Ajuste simple en resize (mantiene vertical y fluido)
window.addEventListener('resize', () => {
  if (running) {
    const newW = Math.min(360, window.innerWidth * 0.9);
    const newH = newW * (16 / 9);
    if (Math.abs(newW - W) > 5 || Math.abs(newH - H) > 5) {
      W = newW;
      H = newH;
      out.width = W;
      out.height = H;
      offCanvas.width = W;
      offCanvas.height = H;
    }
  }
});
})();
</script>
</body>
</html>
